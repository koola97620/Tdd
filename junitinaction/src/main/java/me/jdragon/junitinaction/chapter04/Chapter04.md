# 04 소프트웨어 테스트 원칙

## 4.1 단위 테스트가 필요한 이유

단위 테스트의 주 목적은 기대한 대로 잘 동작하는지 증명하고, 버그를 조기에 잡아내기 위함이다

단위테스트 특징
- 기능 테스트보다 훨씬 높은 테스트 커버뤼지
- 팀 생산성 향상?
- 회귀 테스트를 수행하고 디버깅의 필요성을 줄여준다
- 리팩토링과 코드 수정 시 올바로 하고 있다는 확신을 보여준다 (검증)
- 구현 품질 향상
- 기대하는 행위를 문서화
- 코드 커버리지 등 각종 측정을 가능하게 한다

### 4.1.1 높은 테스트 커버리지 달성

단위 테스트는 가장 먼저 수행되어야 할 테스트다
기능 테스트는 애플리케이션 코드의 약 70%? 를 커버하지만 단위테스틑 더 높다
기능 테스트로는 어려운 오류 상황 시뮬레이션도 단위 테스트라면 쉽게 할 수 있다

### 4.1.2 팀 생산성 향상

단위 테스트를 잘 수행하면 다른 컴포넌트가 완료될 때까지 기다리지 않고도 품질 높은 코드를 납품할 수 있다
기능 테스트는 상대적으로 정밀한 테스트를 하지 못하고 테스트 하려면 동작하는 기능이 준비되어야 한다


### 4.1.3 회귀 테스트 수행 및 디버깅 감소

리팩토링 이나 새 기능을 추가하기 위해 코드를 수정해도 좋다는 확신을 안겨준다
단위 테스트는 어떤 메서드가 어떤 이유로 실패했는지 이야기 해준다

### 4.1.4 확신에 찬 리팩토링

단위 테스트가 없다면 어느 코드를 수정했을 때 제품코드에 어떤 영향이 생기게 될지 빠른 시간안에 알기 힘들다
물론 알 수는 있지만... 단위 테스트가 존재하면 그 속도가 배로 향상된다

하나의 유스케이스나 기능만을 위해 설계와 구현을 하면 일단은 기 기능에 적합한 구조가 나올진 모르나
차후에 더해질 기능에는 적합하지 않을 가능성이 있다. 리팩토링이 필요한 시점이다.

리팩토링이 기존 코드를 망가뜨리지 않는다고 어떻게 확신할 수 있을까?
단위테스트는 어느 부분의 코드가 망가졌는지를 알려준다.

> 즉, 단위 테스트는 리팩토링에 대한 확신을 심어준다.

### 4.1.5 구현 품질 향상

단위 테스트는 대상 api 가 유연하고 독립적으로 테스트 가능하게 만들어질 것을 강요한다.
단위 테스트하기 어려운 코드?? 단위테스트가 가능하게끔 리팩토링 해라. 혹은 TDD 를 따라라

### 4.1.6 기대 행위 문서화

단위 테스트는 api 또는 특정 기능의 사용법을 보여주는 예제이다.
기능의 인풋과 아웃풋, 그리고 예외상황을 알려준다.

### 4.1.7 코드 커버리지 등 각종 측정이 가능

코드 커버리지, 빌드 성공/실패 추이.
수행 성능을 측정하여 이전 빌드 대비 안 좋은 결과가 나오면 실패하는 테스트를 작성하는 것도 가능하다


## 4.2 테스트의 종류

테스트 종류
- Acceptance testing
- Stress/load testing
- Functional testing
- Integration testing
- Unit testing

아래에서 위로 갈 수록 기능 검증의 비중이 커지고 애플리케이션의 더 많은 부분이 준비되어 있어야 수행이 가능하다

### 4.2.1 소프트웨어 테스트의 네 가지 종류

통합 테스트
- 컴포넌트간의 상호작용을 테스트 하는 것
- 대상 클래스를 로딩하고 실행하는 테스트가 유닛테스트다
- 유닛테스트의 클래스를 다른 메서드나 서비스와 연동시키는 것이 통합테스트다

- 객체 간 상호작용 : 객체 생성, 객체에 정의된 메서드 호출
- 서비스 간 상호작용 : 서블릿이나 EJB 컨테이너는 데이터베이스에 연결되거나 , 필요한 외부 자원,기기를 사용할 수 있다
- 서브 시스템 간 상호작용 : 프론트엔드로부터 요청이 잘 전달되어 백엔드가 적절히 응답하는지를 검사할 수 있다

기능 테스트
- 애플리케이션을 유스케이스 단위로 테스트

스트레스 테스트
- 대부분의 스트레스 테스트는 주어진 단위 시간 동안 애플리케이션이 얼마나 많은 요청을 처리할 수 있는가를 검사한다
- 미리 프로그램된 요청을 자동으로 보내면서 애플리케이션이 반응하는 속도를 추적한다
- 보통 이러한 속도 응답의 정확성은 간과하기 때문에 정확성 확인을 위한 테스트도 병행해줘야한다
- 성능 테스트 1규칙, 하지말라! : 풀어야 할 명확한 문제가 없는 한 코드 최적화에 시간을 허비하지 마라
  즉, 코드 최적화 전에 성능 테스트가 반드시 선행 되어야 한다는 것이다.

인수 테스트
- 고객과 이해관계자가 정의한 모든 목적에 부합되는지 확인해보고자 하는 테스트
- 모든 종류의 테스트를 포함할 수 있다.
- 궁금하면 다른곳에서 더 알아봐!


### 4.2.2 단위 테스트의 종류 세 가지

화이트 박스 테스트 : 테스트 작성 시 상세 구현 지식이 활용되는 경우

논리 단위 테스트
- 한 메서드에 집중한 테스트
- 목 객체나 스텁을 이용해 테스트 메서드의 경계를 제어할 수 있다

통합 단위 테스트
- 실제 운영환경에서 컴포넌트 간 연동에 치중한 테스트, 예를 들어 DB를 사용하는 코드라면 DB를 효과적으로 호출하는 가를 테스트 할 수 있다

기능 단위 테스트
- 자극 반응을 확인하기 위해 통합 단위 테스트의 경계를 확장한 테스트.
- 예를 들어 로그인을 하지 않은 채 보안 페이지에 접근하면, 클라이언트를 로그인 페이지로 돌려보내야 한다
  이 상황을 검사하려면 기능 단위 테스트는 이 페이지에 접속하려는 HTTP 요청을 보내고, 응답으로
  재전송 코드가 오는지 확인하는 방법이 있다
- 컨트롤러가 올바른 기능을 호출하고, 기대한 화면을 전송하는지 검사한다
  하지만 그 화면이 실제 존재하는지 혹은 렌더링이 올바른지는 확인하지 않는다.

코드 동작 여부를 확신하려면 세 가지 테스트가 모두 필요하다
엄밀히 말해 기능 단위 테스트를 단위 테스트라 보긴 어렵다
그렇지만 기능 단위 테스트도 개발 시 수행되는 테스트들의 일부로 유용하게 쓰이는 경우가 많기에 테스트 범주에 포함 시키는게 좋다


이러한 테스트 종류들이 잘 구현되어 있으면 언제나 확신을 가지고 개발에 임할 수 있다
무엇이 어디서 잘못됐는지 정확히 알 수 있기 때문에 문제해결에 집중할 수 있다.


## 4.3 블랙박스 테스트와 화이트박스 테스트

블랙박스 테스트
대상 시스템의 내부 상태와 동작에 대한 아무런 정보가 없다.
테스트는 순전히 시스템의 외부 인터페이스에 의존해 정확성을 검증한다

겉에 버튼과 LED 만 존재하는 상자를 상상해보자
버튼을 누르면 상타가 특정 패턴으로 LED를 깜박인다
이 테스트에 필요한 것은 상자의 기능명세뿐이다
이런 명세는 프로젝트 초기에 작성하게 되고, 이는 곧 프로젝트 초기부터 테스트가 가능함을 말한다.
엔지니아, 개발자, 고객 모두가 테스트에 참여할 수 있다


블랙박스 테스트의 가장 단순한 형태는 수동으로 사용자 인터페이스를 조작하는 식이다.


화이트박스 테스트
테스트를 작성할 때 구현에 대한 상세지식을 모두 활용한다
컴포넌의 구현 요구사항, 다른 컴포넌트와의 연동방식까지도 활용

사용자 중심적인 테스트 vs 시스템의 상세 구현 정보를 활용한 테스트

사용자 중심 접근법
- 고객에게 테스트 스크립트를 주고 자기손으로 수행하도록 해준다면 더 좋은 결과를 얻을수도
- 고객은 시스템이 무엇을 해야 하는지 명확히 정의할 수 있다

테스트 난이도
- 블랙박스 테스트의 대상은 그래픽 사용자 인터페이스를 제공하는 경우가 보통이다
- 테스트 작성이 더 어렵다
- 구현과 수행 면에서는 대부분 화이트박스 테스트가 용이하지만, 반드시 개발자가 직접 구현해야 한다

테스트 커버리지
- 화이트박스가 블랙보다 일반적으로 높다
- 제공하는 가치 면에서는 블랙박스가 더 높다

## 4.4 정리

- 테스트가 개발의 뒤만 졸졸 따르던 폭포수 모델로부터 벗어나야 한다
- 논리, 통합, 기능 세 가지 종류의 단위테스트는 모두 개발에 유익하며 상호 보완적이다
