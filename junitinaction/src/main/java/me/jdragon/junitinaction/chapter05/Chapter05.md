# 05 테스트 커버리지와 개발

## 5.1 테스트 커버리지 측정하기

단위테스트를 잘 작성해두면 코드 수정 및 리팩토링 시 자신감이 생겨난다.
코드를 수정할 때마다 테스트를 실행해주면 새로 추가한 기능이 잘 동작하는지,
변경한 코드가 기존 코드에 문제를 일으키지는 않는지 즉각적인 피드백을 얻을 수 있다

### 5.1.1 테스트 커버리지란?

블랙박스 테스트 방식 측정 방식
- 테스트에 의해 호출된 메서드들을 추적해 보여주기
- 특정 메서드를 검사하는 테스트가 존재하는지 정도는 알 수 있다

화이트박스 테스트 방식 측정 방식
- 단위 메서드 구현에 대한 자세한 지식을 활용해 단위 테스트 작성
- 조건분기가 있다면 각 분기별 단위테스트를 마련할 수 있다.
- 메서드 내부를 들여다 보는 테스트
- 100% 커버리지 달성

화이트 박스 테스트라면 더 많은 메서드에 접근할 수 있다
각 메서드의 입력과 보조 객체의 동작까지 제어할 수 있다

### 5.1.2 Cobertura 소개
### 5.1.3 테스트 커버리지 보고서 생성하기

### 5.1.4 블랙박스 테스트와 화이트박스 테스트 혼용하기

블랙박스 테스트 : 객체 간 상호작용을 검사
화이트박스 테스트 : 객체 간 상호작용 검사하지 않는다

## 5.2 테스트 가능한 코드 작성하기

테스트 케이스를 작성하기 어려울 때도 있다.
이는 애플리케이션 복잡도에 달려있다. 가독성 높고 테스트 가능한 코드를 작성하라는 모범 사례를
잘 따른다면 복잡도를 낮출 수 있다.

기존 코드를 리팩토링해서 테스트하기 쉬운 코드를 만드는것보다
처음부터 쉬운 코드를 작성하도록 노력하자

### 5.2.1 공개 API 는 계약이다

공개 메서드의 시그니처를 변경하면, 이를 호출하는 모든 코드와 단위테스트도 수정해야 한다

컴파일 단계는 문제 없지만 동작할 때 문제를 일으킬 수 있다.
잘못된 부분을 찾아주는 단위테스트가 없다면 원인을 찾는데 오래 걸릴것이다.
반드시 모든 공개 메서드를 테스트해야 한다

비공개 메서드는 화이트 박스 테스트를 사용해야 한다

### 5.2.2 종속성을 줄여라

단위 테스트는 코드를 고립시켜 검증함을 기억하자
대상 클래스가 일련의 다른 객체들을 직접 혹은 간접적으로 생성하고 있다면??
그 클래스는 다른 클래스에 종속되어 버린다.

테스트 가능한 코드를 작성하려면 이런 종속성을 가능한 최소화 시켜야 한다.
클래스가 다수의 다른 클래스들에 종속되어 특정 상태로 셋팅되어 있다면? 테스트가 복잡해진다.

종속성을 줄이는 방법은 코드에서 객체 생성을 담당하는 메서드와 로직 수행 메서드를 분리하는 것이다

~~~ java
public class Vehicle {
  Driver d = new Driver();
  boolean hasDriver = true;
  private void setHasDriver(boolean hasDriver) {
    this.hasDriver = hasDriver;
  }
}
~~~

Vehicle 객체는 자신이 생성될 때마다 Driver 객체도 함께 생성된다. 개념이 섞어벼렸다.
Driver 를 Vehicle 이 생성될 때 건네주는 식으로 만들자. (new 를 없애는 것이다)

### 5.2.3 생성자는 간단하게 만들어라

테스트 케이스의 과정은 다음과 같다
- 테스트하려는 클래스를 생성한다
- 생성한 클래스를 특정한 상태가 되도록 설정한다
- 클래스의 최종 상태를 확인한다

인스턴스 변수에 값을 할당하는게 아니고, 생성자에서 작업을 수행하게 되면
생성한 클래스가 특정 상태가 되게 설정되어 버린다. 이는 항상 똑같은 상태만 얻는다는 것이다.
유연한 코드가 될 수 없다

### 5.2.4 최소 지식의 원칙을 따르라

최소 지식의 원칙은 클래스는 반드시 자신에게 꼭 필요한 만큼만 알아야 한다.

~~~ java
public class Car {
  private Driver driver;
  public Car(Context context) {
    this.driver = context.getDriver();
  }

}
~~~

Car 클래스는 Context 객체가 getDriver 메서드를 가지고 있음을 알아야만 하므로 디미터의 법칙에 위배된다
이 생성자를 테스트 하려면 context 객체가 유효한지부터 확인해야 한다.
Context 객체에 포함된 변수와 메서드가 많다면 목객체를 사용할 수 밖에 없다.

적절한 해법은 최소 지식의 원칙을 적용하여 꼭 필요한 경우에만 메서드와 생성자에 참고를 건네는 것이다.

~~~ java
public Car(Driver driver) {
    this.driver=driver;
  }
~~~

아래 지침을 명심하자.
- 객체를 요구하되, 객체를 검색하지는 말라
- 애플리케이션에 꼭 필요한 객체만 요청하라


### 5.2.5 숨겨진 종속성과 전역 상태를 피하라

전역 상태는 복수의 클라이언트들이 동일한 전역 객체를 공유하도록 허용하므로 주의해서 사용해야 한다.

Reservation 은 데이터베이스 생성이 선행되어야만 한다. 데이터베이스에 접근하기 위해 내부적으로 DBManager 를 사용한다.
Reservation 클래스의 api는 DBManager를 사용해야 한다는 어떠한 단서도 제공하지 않는다.

이는 종속성을 숨기는 행위이다.
코드만 보고 어떤 클래스를 사용하기 위해서 사전조건이 필요하다는 것을 파악하기 힘든것을
숨겨진 종속성이라고 한다??

~~~ java

// 전역상태를 사용하는 예
public void reserve1() {
    DBManager manager = new DBManager();
    manager.initDatabase();
    Reservation r = new Reservation();
    r.reserve();
  }
// 전역상태 회피한 예
  public void reserve2() {
    DBManager manager = new DBManager();
    manager.initDatabase();
    Reservation reservation = new Reservation(manager);
    reservation.reserve();
  }
~~~

아래 예에서는 Reservation 객체 생성시에 DBManager 를 명시적으로 받고 있다.
이는 Reservation 객체는 DBManager 가 설정되었을 때만 동작할 수 있다는걸 말해준다.

> 전역 객체에 접근해야 할 때는, 그 객체뿐 아니라 그 객체가 참고하는 다른 모든 객체도 함께 공유해야 한다.


### 5.2.6 싱글톤의 장단점

싱글톤 : 클래스의 인스턴스가 오직 하나 뿐임을 보장하는 디자인 패턴

~~~ java
public class Singleton {
//  private Singleton() {}
//  public static final Singleton INSTANCE = new Singleton();

  private static Singleton INSTANCE;
  private Singleton() {}
  public static Singleton getInstance() {
    if(INSTANCE == null) {
      INSTANCE = new Singleton();
    }
    return INSTANCE;
  }
}
~~~

보통 private 생성자와 정적 변수를 사용해서 생성한다.(주석)
다른 방법으로는 지연 초기화가 많이 사용된다. (아래 방법)

싱글톤 디자인 패턴은 객체가 단 **한번만** 인스턴스화됨을 보장해야 한다.
이를 위해 생성자를 private 으로 숨긴다.
싱글톤은 전역 상태를 만들어 낸다는 명백한 취약점이 존재한다.

### 5.2.7 제너릭 메서드를 애용하라

팩토리 메서드와 같은 정적 메서드는 유용하지만, 유틸리티 성격의 정적 메서드가 늘어나면 문제를 야기한다.
단위테스트는 고립 상태에서의 테스트임을 명심하자.
고립상태로 만들기 위해선 코드 상에 연결점을 준비하여 필요시에 쉽게 테스트 코드로 대체할 수 있도록 만들어야 한다

연결점들은 **다형성**을 활용한다. 다형성을 활용하면 호출하는 메서드가 런타임에 결정된다.
또한 애플리케이션 코드를 테스트 코드로 쉽게 대체하여 임의적으로 특정 코드 패턴을 검사할 수 있다.

정적메서드를 사용하면 호출할 모든 메서드가 컴파일 시간에 결정되기 때문에 원하는 시점에
코드를 대체할 수 있는 연결점은 더이상 존재하지 않는 것이다.

로직이 종결되는 메서드들은 문제가 되지 않는다.
하지만 로직의 중간 지점에 위치한 메서드는 내부적으로 호출하는 모든 메서드 테스트가 난해해진다.

다형성이 불가능하다 --> 코드 재활용이 불가능하다 --> 코드 중복 생성으로 이어질 수 있다.

### 5.2.8 상속보다는 컴포지션을 활용하라

실행 도중에 상속 관계를 변경할 순 없지만 객체 조합을 변경하는 것은 얼마든지 가능하다.

모든 서블릿이 인증 서블릿을 상속받게 하면 테스트에서 사용할 때마다 인증 정보를 생성해야 한다.
필요한 서블릿에 Credential 인스턴스 변수를 추가(조립)한다면, 필요할 때만 변수가 생성되므로 테스트가 수월하다

### 5.2.9 조건 분기보다 다형성을 활용하라

switch case 예
한 종류가 추가될 때마다 새로운 case 절을 추가해야 한다.
같은 코드가 여기저기 등장한다면? 변경시 바뀐 부분을 모두 찾아 바꿔줘야 한다.

긴 조건문을 만나면 다형성을 고려해봐라
다형성은 한 클래스를 여러개의 작은 클래스로 나누어 긴 조건문 사용을 회피할 수 있게 해주는 객체지향 기법이다


## 5.3 테스트 주도 개발

테스트를 작성하는 것이 초기 설계를 향상시키는데 도움이 될 수 있다.

테스트 주도 개발
자동화 테스트가 실패했을 때와 코드 중복을 제거하려 할 때에만 새로운 코드를 작성하도록 권하는 프로그래밍 실천법

### 5.3.1 개발 주기 조정하기

전통적 개발 순서는 코딩 -> 테스트 -> (반복) -> 커밋 순으로 이루어진다
TDD 는 테스트 -> 코드 -> (반복) -> 커밋 순으로 이루어진다.
테스트가 설계를 이끄는 것이다.

기능을 정의하고 구현을 하려고 할때? 처음에는 가정에 의존해야 하지만
단위 테스트를 작성하면 코드 설계에 집중할 수 있다?
그리고 구현을 끝마치는 즉시, 테스트를 수행하여 정확히 구현됐는지 확인할 수 있다.

선 테스트 작성의 의미
- 코드를 설계한다
- 코드의 동작 방식을 문서화한다
- 코드를 단위 테스트 한다


### 5.3.2 TDD 실천으로 가는 두 단계

테스트 -> 코드 -> 리팩토링 -> (반복) -> 커밋 이어야 한다.

TDD 계명
- 새 코드를 작성하기에 앞서 실패하는 자동화 테스트를 작성하라
- 중복을 제거하라

TDD 는 중복을 제거함으로써 유지보수가 쉬운 코드를 작성하도록 유도한다.

JUnit 모범 사례 : 실패하는 테스트를 먼저 작성하라.
- 새로운 코드를 작성하려면 반드시 실패하는 테스트를 먼저 작성해야 한다
- 왜만드냐? 그 일을 성공케 하는 코드를 아직 작성하지 못했기 때문이다.
- 실패한 테스트를 해결하는 단순한 구현을 찾아서 성공시킨다.
- 그리고 잉여로직을 제거하고 의도를 명확히 하고 최적화 시킨다 (리팩토링)
- 결론은 항상 테스트를 먼저 작성하고, 이후에 성공시키는 코드를 만들어라

## 5.4 개발 주기에서의 테스트

개발 플랫폼
- 개발자의 컴퓨터에서 코딩이 이루어진다.
- 동작하는 코드만을 커밋해야 한다.
- 단위 테스트
- 논리 단위 테스트(주변과 격리된)를 수행한다.
- 통합단위 테스트 이 단계에서 수행할 수 있지만, 데이터베이스, 서버 등이 필요할 수 있다.

통합 플랫폼
- 서로 다른 팀에 의해 만들어진 컴포넌트도 모두 한곳에 모인다.
- 통합과정에서 많은 문제가 발견되기 때문에 자동화가 필요하다 (지속적통합)
- 단위 테스트 + 기능 테스트
- 애플리케이션의 패키징, 배포/단위 기능 테스트까지 자동으로 수행되도록 하는 것이 보통이다.
- 프로덕션 플랫폼과 비교해서 일부 구성 요소가 누락되어 있는 간소화된 플랫폼이다.
- 모든 단위테스트 수행이 가능 하다.

인수 플랫폼/스트레스 테스트 플랫폼
- 애플리케이션에 부하를 가하면서 정확히 동작하는가를 검사한다
- 규모와 응답 시간이 평가 기준이 된다
- 단위 테스트 + 기능 테스트 + 스트레스 테스트
- 통합 테스트에 성능 테스트 혹은 부하 테스트가 더해진다.

프로덕션 플랫폼
- 실제 운영환경
- 단위 테스트 + 기능 테스트 + 스트레스 테스트

JUnit 모범 사례 : 지속적으로 회귀 테스트를 수행하라
- 새 기능을 작성하면 새로운 테스트를 작성한다
- 새 기능과 다른 것들이 잘 어울려 동작하는지 확인한다. 대부분의 새 기능은 기존 코드를 건드린다.
- 기존 코드 + 새 코드를 이용해서 새 기능을 구현했을 때, 기존의 기능들이 잘 수행되는지 확인해야 한다
- 새 코드 구현하고 그와 관련된 모든 테스트가 통과할 때까지 코드를 고쳐 나간다
- 회귀 테스트 : 수정 코드 때문에 기존 기능이 오동작하는 것을 막기 위한 목적으로 이전 테스트를 재활용 하는것











